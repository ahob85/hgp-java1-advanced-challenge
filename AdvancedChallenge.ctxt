#BlueJ class context
comment0.target=AdvancedChallenge
comment0.text=\n\ Write\ a\ description\ of\ class\ AdvancedChallenge\ here.\n\n\ @author\ (your\ name)\n\ @version\ (a\ version\ number\ or\ a\ date)\n
comment1.params=nums
comment1.target=boolean\ canBalance(int[])
comment1.text=\n\ Given\ a\ non-empty\ array,\ return\ true\ if\ there\ is\ a\ place\ to\ split\ the\ \n\ array\ so\ that\ the\ sum\ of\ the\ numbers\ on\ one\ side\ is\ equal\ to\ the\ sum\ \n\ of\ the\ numbers\ on\ the\ other\ side.\n\ \n\ Examples\:\n\ canBalance([1,\ 1,\ 1,\ 2,\ 1])\ \u2192\ true\n\ canBalance([2,\ 1,\ 1,\ 2,\ 1])\ \u2192\ false\n\ canBalance([10,\ 10])\ \u2192\ true\n
comment2.params=nums
comment2.target=int\ maxSpan(int[])
comment2.text=\n\ Consider\ the\ leftmost\ and\ righmost\ appearances\ of\ some\ value\ in\ an\ \n\ array.\ We'll\ say\ that\ the\ "span"\ is\ the\ number\ of\ elements\ between\ the\ \n\ two\ inclusive.\ A\ single\ value\ has\ a\ span\ of\ 1.\ Returns\ the\ largest\ \n\ span\ found\ in\ the\ given\ array.\n\ \n\ Examples\:\n\ maxSpan([1,\ 2,\ 1,\ 1,\ 3])\ \u2192\ 4\n\ maxSpan([1,\ 4,\ 2,\ 1,\ 4,\ 1,\ 4])\ \u2192\ 6\n\ maxSpan([1,\ 4,\ 2,\ 1,\ 4,\ 4,\ 4])\ \u2192\ 6\n
comment3.params=outer\ inner
comment3.target=boolean\ linearIn(int[],\ int[])
comment3.text=\n\ Given\ two\ arrays\ of\ numbers\ sorted\ in\ increasing\ order,\ outer\ and\ \n\ inner,\ return\ true\ if\ all\ of\ the\ numbers\ in\ inner\ appear\ in\ outer.\ The\ \n\ best\ solution\ makes\ only\ a\ single\ "linear"\ pass\ of\ both\ arrays,\ taking\ \n\ advantage\ of\ the\ fact\ that\ both\ arrays\ are\ already\ in\ sorted\ order.\n\ \n\ Examples\:\n\ linearIn([1,\ 2,\ 4,\ 6],\ [2,\ 4])\ \u2192\ true\n\ linearIn([1,\ 2,\ 4,\ 6],\ [2,\ 3,\ 4])\ \u2192\ false\n\ linearIn([1,\ 2,\ 4,\ 4,\ 6],\ [2,\ 4])\ \u2192\ true\n
comment4.params=nums
comment4.target=int[]\ fix45(int[])
comment4.text=\n\ Return\ an\ array\ that\ contains\ exactly\ the\ same\ numbers\ as\ the\ given\ \n\ array,\ but\ rearranged\ so\ that\ every\ 4\ is\ immediately\ followed\ by\ a\ 5.\ \n\ Do\ not\ move\ the\ 4's,\ but\ every\ other\ number\ may\ move.\ The\ array\ \n\ contains\ the\ same\ number\ of\ 4's\ and\ 5's,\ and\ every\ 4\ has\ a\ number\ \n\ after\ it\ that\ is\ not\ a\ 4.\ 5's\ may\ appear\ anywhere\ in\ the\ original\ \n\ array.\n\ \n\ Examples\:\n\ fix45([5,\ 4,\ 9,\ 4,\ 9,\ 5])\ \u2192\ [9,\ 4,\ 5,\ 4,\ 5,\ 9]\n\ fix45([1,\ 4,\ 1,\ 5])\ \u2192\ [1,\ 4,\ 5,\ 1]\n\ fix45([1,\ 4,\ 1,\ 5,\ 5,\ 4,\ 1])\ \u2192\ [1,\ 4,\ 5,\ 1,\ 1,\ 4,\ 5]\n
comment5.params=n
comment5.target=int[]\ squareUp(int)
comment5.text=\n\ Given\ n>\=0,\ return\ an\ array\ length\ n*n\ with\ the\ following\ pattern,\ \n\ shown\ here\ for\ n\=3\:\ \n\ {0,\ 0,\ 1,\ \ \ 0,\ 2,\ 1,\ \ \ 3,\ 2,\ 1}\ (spaces\ added\ to\ show\ the\ 3\ groups).\n\ \n\ Examples\:\n\ squareUp(3)\ \u2192\ [0,\ 0,\ 1,\ 0,\ 2,\ 1,\ 3,\ 2,\ 1]\n\ squareUp(2)\ \u2192\ [0,\ 1,\ 2,\ 1]\n\ squareUp(4)\ \u2192\ [0,\ 0,\ 0,\ 1,\ 0,\ 0,\ 2,\ 1,\ 0,\ 3,\ 2,\ 1,\ 4,\ 3,\ 2,\ 1]\n
numComments=6
